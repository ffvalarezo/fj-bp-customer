<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/SecurityConfig.java" />
              <option name="originalContent" value="package com.pichincha.movement.configuration;&#10;&#10;import java.time.Instant;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;&#10;import org.springframework.security.config.web.server.ServerHttpSecurity;&#10;import org.springframework.security.oauth2.jwt.Jwt;&#10;import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;&#10;import org.springframework.security.web.server.SecurityWebFilterChain;&#10;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.security.Keys;&#10;import reactor.core.publisher.Mono;&#10;&#10;@Configuration&#10;@EnableReactiveMethodSecurity&#10;public class SecurityConfig {&#10;&#10;  @Value(&quot;${jwt.secret:mySecretKey}&quot;)&#10;  private String jwtSecret;&#10;&#10;  @Bean&#10;  public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {&#10;    return http&#10;        .csrf(csrf -&gt; csrf.disable())&#10;        .authorizeExchange(exchange -&gt; exchange&#10;            .pathMatchers(&quot;/api/auth/**&quot;, &quot;/webjars/**&quot;, &quot;/actuator/**&quot;,&#10;                &quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;)&#10;            .permitAll()&#10;            .anyExchange()&#10;            .authenticated())&#10;        .oauth2ResourceServer(oauth2 -&gt; oauth2&#10;            .jwt(jwt -&gt; jwt.jwtDecoder(jwtDecoder())))&#10;        .build();&#10;  }&#10;&#10;  @Bean&#10;  public ReactiveJwtDecoder jwtDecoder() {&#10;    return token -&gt; {&#10;      if (token == null || token.isBlank()) {&#10;        return Mono.error(new RuntimeException(&quot;JWT token is missing or empty&quot;));&#10;      }&#10;      try {&#10;        var claimsJws = Jwts.parser()&#10;            .setSigningKey(Keys.hmacShaKeyFor(jwtSecret.getBytes()))&#10;            .parseClaimsJws(token);&#10;        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(claimsJws.getBody());&#10;        Jwt jwt = new Jwt(&#10;            token,&#10;            Instant.ofEpochMilli(claimsJws.getBody().getIssuedAt().getTime()),&#10;            Instant.ofEpochMilli(claimsJws.getBody().getExpiration().getTime()),&#10;            Map.of(&quot;alg&quot;, &quot;HS256&quot;),&#10;            claims&#10;        );&#10;        return Mono.just(jwt);&#10;      } catch (Exception e) {&#10;        return Mono.error(new RuntimeException(&quot;Invalid JWT&quot;, e));&#10;      }&#10;    };&#10;  }&#10;}" />
              <option name="updatedContent" value="package com.pichincha.movement.configuration;&#10;&#10;import java.time.Instant;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;&#10;import org.springframework.security.config.web.server.ServerHttpSecurity;&#10;import org.springframework.security.oauth2.jwt.Jwt;&#10;import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;&#10;import org.springframework.security.web.server.SecurityWebFilterChain;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.reactive.CorsConfigurationSource;&#10;import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;&#10;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.security.Keys;&#10;import reactor.core.publisher.Mono;&#10;&#10;@Configuration&#10;@EnableReactiveMethodSecurity&#10;public class SecurityConfig {&#10;&#10;  @Value(&quot;${jwt.secret:mySecretKey}&quot;)&#10;  private String jwtSecret;&#10;&#10;  @Bean&#10;  public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {&#10;    return http&#10;        .csrf(csrf -&gt; csrf.disable())&#10;        .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;        .authorizeExchange(exchange -&gt; exchange&#10;            .pathMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()&#10;            .pathMatchers(&quot;/api/auth/**&quot;, &quot;/webjars/**&quot;, &quot;/actuator/**&quot;, &#10;                &quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;)&#10;            .permitAll()&#10;            .anyExchange()&#10;            .authenticated())&#10;        .oauth2ResourceServer(oauth2 -&gt; oauth2&#10;            .jwt(jwt -&gt; jwt.jwtDecoder(jwtDecoder())))&#10;        .build();&#10;  }&#10;&#10;  @Bean&#10;  public CorsConfigurationSource corsConfigurationSource() {&#10;    CorsConfiguration configuration = new CorsConfiguration();&#10;    configuration.setAllowCredentials(true);&#10;    configuration.addAllowedOriginPattern(&quot;*&quot;);&#10;    configuration.addAllowedMethod(&quot;*&quot;);&#10;    configuration.addAllowedHeader(&quot;*&quot;);&#10;    configuration.addExposedHeader(&quot;x-app&quot;);&#10;    configuration.addExposedHeader(&quot;x-guid&quot;);&#10;    configuration.addExposedHeader(&quot;x-channel&quot;);&#10;    configuration.addExposedHeader(&quot;x-medium&quot;);&#10;    configuration.addExposedHeader(&quot;x-session&quot;);&#10;    &#10;    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;    source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;    return source;&#10;  }&#10;&#10;  @Bean&#10;  public ReactiveJwtDecoder jwtDecoder() {&#10;    return token -&gt; {&#10;      if (token == null || token.isBlank()) {&#10;        return Mono.error(new RuntimeException(&quot;JWT token is missing or empty&quot;));&#10;      }&#10;      try {&#10;        var claimsJws = Jwts.parserBuilder()&#10;            .setSigningKey(Keys.hmacShaKeyFor(jwtSecret.getBytes()))&#10;            .build()&#10;            .parseClaimsJws(token);&#10;        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(claimsJws.getBody());&#10;        Jwt jwt = new Jwt(&#10;            token,&#10;            Instant.ofEpochMilli(claimsJws.getBody().getIssuedAt().getTime()),&#10;            Instant.ofEpochMilli(claimsJws.getBody().getExpiration().getTime()),&#10;            Map.of(&quot;alg&quot;, &quot;HS256&quot;),&#10;            claims&#10;        );&#10;        return Mono.just(jwt);&#10;      } catch (Exception e) {&#10;        return Mono.error(new RuntimeException(&quot;Invalid JWT&quot;, e));&#10;      }&#10;    };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/WebClientConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/WebClientConfig.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/domain/LoginResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/domain/LoginResponse.java" />
              <option name="updatedContent" value="package com.pichincha.movement.domain;&#10;&#10;import java.util.Map;&#10;&#10;public record LoginResponse(&#10;  String token,&#10;  String refreshToken,&#10;  long expiresIn,&#10;  Map&lt;String, Object&gt; user&#10;) {&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/infrastructure/input/adapter/rest/AuthController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/infrastructure/input/adapter/rest/AuthController.java" />
              <option name="originalContent" value="package com.pichincha.movement.infrastructure.input.adapter.rest;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PostMapping;&#10;import org.springframework.web.bind.annotation.RequestBody;&#10;import org.springframework.web.bind.annotation.RequestMapping;&#10;import org.springframework.web.bind.annotation.RestController;&#10;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.SignatureAlgorithm;&#10;import io.jsonwebtoken.security.Keys;&#10;import reactor.core.publisher.Mono;&#10;&#10;import java.util.Date;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/auth&quot;)&#10;public class AuthController {&#10;&#10;&#9;@Value(&quot;${jwt.secret:mySecretKey}&quot;)&#10;&#9;private String jwtSecret;&#10;&#10;&#9;@Value(&quot;${jwt.username:username}&quot;)&#10;&#9;private String username;&#10;&#10;&#9;@Value(&quot;${jwt.password:password}&quot;)&#10;&#9;private String password;&#10;&#10;&#9;@GetMapping(&quot;/ping&quot;)&#10;&#9;public Mono&lt;String&gt; ping() {&#10;&#9;&#9;return Mono.just(&quot;API está funcionando sin autenticación.&quot;);&#10;&#9;}&#10;&#10;&#9;@PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;&#9;@GetMapping(&quot;/admin&quot;)&#10;&#9;public Mono&lt;String&gt; adminOnlyAccess() {&#10;&#9;&#9;return Mono.just(&quot;Acceso concedido al ADMIN&quot;);&#10;&#9;}&#10;&#10;&#9;@PostMapping(value = &quot;/login&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)&#10;&#9;public Mono&lt;String&gt; login(@RequestBody Map&lt;String, String&gt; credentials) {&#10;&#9;&#9;String username = credentials.get(&quot;username&quot;);&#10;&#9;&#9;String password = credentials.get(&quot;password&quot;);&#10;&#9;&#9;if (username.equals(this.username) &amp;&amp; password.equals(this.password)) {&#10;&#9;&#9;&#9;String token = Jwts.builder().setSubject(username).claim(&quot;roles&quot;, &quot;ROLE_ADMIN&quot;).setIssuedAt(new Date())&#10;&#9;&#9;&#9;&#9;&#9;.setExpiration(new Date(System.currentTimeMillis() + 3600000))&#10;&#9;&#9;&#9;&#9;&#9;.signWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()), SignatureAlgorithm.HS256).compact();&#10;&#9;&#9;&#9;return Mono.just(token);&#10;&#9;&#9;}&#10;&#9;&#9;return Mono.error(new RuntimeException(&quot;Invalid credentials&quot;));&#10;&#9;}&#10;}" />
              <option name="updatedContent" value="package com.pichincha.movement.infrastructure.input.adapter.rest;&#10;&#10;import com.pichincha.movement.domain.LoginResponse;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.security.access.prepost.PreAuthorize;&#10;import org.springframework.web.bind.annotation.GetMapping;&#10;import org.springframework.web.bind.annotation.PostMapping;&#10;import org.springframework.web.bind.annotation.RequestBody;&#10;import org.springframework.web.bind.annotation.RequestMapping;&#10;import org.springframework.web.bind.annotation.RestController;&#10;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.SignatureAlgorithm;&#10;import io.jsonwebtoken.security.Keys;&#10;import reactor.core.publisher.Mono;&#10;&#10;import java.util.Date;&#10;import java.util.Map;&#10;import java.util.HashMap;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/auth&quot;)&#10;public class AuthController {&#10;&#10;&#9;@Value(&quot;${jwt.secret:mySecretKey}&quot;)&#10;&#9;private String jwtSecret;&#10;&#10;&#9;@Value(&quot;${jwt.username:username}&quot;)&#10;&#9;private String username;&#10;&#10;&#9;@Value(&quot;${jwt.password:password}&quot;)&#10;&#9;private String password;&#10;&#10;&#9;@GetMapping(&quot;/ping&quot;)&#10;&#9;public Mono&lt;String&gt; ping() {&#10;&#9;&#9;return Mono.just(&quot;API está funcionando sin autenticación.&quot;);&#10;&#9;}&#10;&#10;&#9;@PreAuthorize(&quot;hasRole('ADMIN')&quot;)&#10;&#9;@GetMapping(&quot;/admin&quot;)&#10;&#9;public Mono&lt;String&gt; adminOnlyAccess() {&#10;&#9;&#9;return Mono.just(&quot;Acceso concedido al ADMIN&quot;);&#10;&#9;}&#10;&#10;&#9;@PostMapping(value = &quot;/login&quot;, consumes = MediaType.APPLICATION_JSON_VALUE)&#10;&#9;public Mono&lt;LoginResponse&gt; login(@RequestBody Map&lt;String, String&gt; credentials) {&#10;&#9;&#9;String username = credentials.get(&quot;username&quot;);&#10;&#9;&#9;String password = credentials.get(&quot;password&quot;);&#10;&#9;&#9;if (username.equals(this.username) &amp;&amp; password.equals(this.password)) {&#10;&#9;&#9;&#9;String token = Jwts.builder().setSubject(username).claim(&quot;roles&quot;, &quot;ROLE_ADMIN&quot;).setIssuedAt(new Date())&#10;&#9;&#9;&#9;&#9;&#9;.setExpiration(new Date(System.currentTimeMillis() + 3600000))&#10;&#9;&#9;&#9;&#9;&#9;.signWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()), SignatureAlgorithm.HS256).compact();&#10;&#10;&#9;&#9;&#9;String refreshToken = Jwts.builder().setSubject(username).setIssuedAt(new Date())&#10;&#9;&#9;&#9;&#9;&#9;.setExpiration(new Date(System.currentTimeMillis() + 7200000))&#10;&#9;&#9;&#9;&#9;&#9;.signWith(Keys.hmacShaKeyFor(jwtSecret.getBytes()), SignatureAlgorithm.HS256).compact();&#10;&#10;&#9;&#9;&#9;Map&lt;String, Object&gt; user = new HashMap&lt;&gt;();&#10;&#9;&#9;&#9;user.put(&quot;username&quot;, username);&#10;&#9;&#9;&#9;user.put(&quot;roles&quot;, &quot;ROLE_ADMIN&quot;);&#10;&#10;&#9;&#9;&#9;LoginResponse response = new LoginResponse(token, refreshToken, 3600, user);&#10;&#9;&#9;&#9;return Mono.just(response);&#10;&#9;&#9;}&#10;&#9;&#9;return Mono.error(new RuntimeException(&quot;Invalid credentials&quot;));&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/AuthService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/AuthService.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginRequest.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginResponse.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/impl/AuthServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/impl/AuthServiceImpl.java" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>