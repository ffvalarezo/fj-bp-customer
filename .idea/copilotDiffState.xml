<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/SecurityConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/SecurityConfig.java" />
              <option name="originalContent" value="package com.pichincha.movement.configuration;&#10;&#10;import java.time.Instant;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;&#10;import org.springframework.security.config.web.server.ServerHttpSecurity;&#10;import org.springframework.security.oauth2.jwt.Jwt;&#10;import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;&#10;import org.springframework.security.web.server.SecurityWebFilterChain;&#10;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.security.Keys;&#10;import reactor.core.publisher.Mono;&#10;&#10;@Configuration&#10;@EnableReactiveMethodSecurity&#10;public class SecurityConfig {&#10;&#10;  @Value(&quot;${jwt.secret:mySecretKey}&quot;)&#10;  private String jwtSecret;&#10;&#10;  @Bean&#10;  public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {&#10;    return http&#10;        .csrf(csrf -&gt; csrf.disable())&#10;        .authorizeExchange(exchange -&gt; exchange&#10;            .pathMatchers(&quot;/api/auth/**&quot;, &quot;/webjars/**&quot;, &quot;/actuator/**&quot;,&#10;                &quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;)&#10;            .permitAll()&#10;            .anyExchange()&#10;            .authenticated())&#10;        .oauth2ResourceServer(oauth2 -&gt; oauth2&#10;            .jwt(jwt -&gt; jwt.jwtDecoder(jwtDecoder())))&#10;        .build();&#10;  }&#10;&#10;  @Bean&#10;  public ReactiveJwtDecoder jwtDecoder() {&#10;    return token -&gt; {&#10;      if (token == null || token.isBlank()) {&#10;        return Mono.error(new RuntimeException(&quot;JWT token is missing or empty&quot;));&#10;      }&#10;      try {&#10;        var claimsJws = Jwts.parser()&#10;            .setSigningKey(Keys.hmacShaKeyFor(jwtSecret.getBytes()))&#10;            .parseClaimsJws(token);&#10;        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(claimsJws.getBody());&#10;        Jwt jwt = new Jwt(&#10;            token,&#10;            Instant.ofEpochMilli(claimsJws.getBody().getIssuedAt().getTime()),&#10;            Instant.ofEpochMilli(claimsJws.getBody().getExpiration().getTime()),&#10;            Map.of(&quot;alg&quot;, &quot;HS256&quot;),&#10;            claims&#10;        );&#10;        return Mono.just(jwt);&#10;      } catch (Exception e) {&#10;        return Mono.error(new RuntimeException(&quot;Invalid JWT&quot;, e));&#10;      }&#10;    };&#10;  }&#10;}" />
              <option name="updatedContent" value="package com.pichincha.movement.configuration;&#10;&#10;import java.time.Instant;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.context.annotation.Bean;&#10;import org.springframework.context.annotation.Configuration;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.security.config.annotation.method.configuration.EnableReactiveMethodSecurity;&#10;import org.springframework.security.config.web.server.ServerHttpSecurity;&#10;import org.springframework.security.oauth2.jwt.Jwt;&#10;import org.springframework.security.oauth2.jwt.ReactiveJwtDecoder;&#10;import org.springframework.security.web.server.SecurityWebFilterChain;&#10;import org.springframework.web.cors.CorsConfiguration;&#10;import org.springframework.web.cors.reactive.CorsConfigurationSource;&#10;import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;&#10;&#10;import io.jsonwebtoken.Jwts;&#10;import io.jsonwebtoken.security.Keys;&#10;import reactor.core.publisher.Mono;&#10;&#10;@Configuration&#10;@EnableReactiveMethodSecurity&#10;public class SecurityConfig {&#10;&#10;  @Value(&quot;${jwt.secret:mySecretKey}&quot;)&#10;  private String jwtSecret;&#10;&#10;  @Bean&#10;  public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {&#10;    return http&#10;        .csrf(csrf -&gt; csrf.disable())&#10;        .cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))&#10;        .authorizeExchange(exchange -&gt; exchange&#10;            .pathMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()&#10;            .pathMatchers(&quot;/api/auth/**&quot;, &quot;/webjars/**&quot;, &quot;/actuator/**&quot;, &#10;                &quot;/swagger-ui/**&quot;, &quot;/v3/api-docs/**&quot;)&#10;            .permitAll()&#10;            .anyExchange()&#10;            .authenticated())&#10;        .oauth2ResourceServer(oauth2 -&gt; oauth2&#10;            .jwt(jwt -&gt; jwt.jwtDecoder(jwtDecoder())))&#10;        .build();&#10;  }&#10;&#10;  @Bean&#10;  public CorsConfigurationSource corsConfigurationSource() {&#10;    CorsConfiguration configuration = new CorsConfiguration();&#10;    configuration.setAllowCredentials(true);&#10;    configuration.addAllowedOriginPattern(&quot;*&quot;);&#10;    configuration.addAllowedMethod(&quot;*&quot;);&#10;    configuration.addAllowedHeader(&quot;*&quot;);&#10;    configuration.addExposedHeader(&quot;x-app&quot;);&#10;    configuration.addExposedHeader(&quot;x-guid&quot;);&#10;    configuration.addExposedHeader(&quot;x-channel&quot;);&#10;    configuration.addExposedHeader(&quot;x-medium&quot;);&#10;    configuration.addExposedHeader(&quot;x-session&quot;);&#10;    &#10;    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;    source.registerCorsConfiguration(&quot;/**&quot;, configuration);&#10;    return source;&#10;  }&#10;&#10;  @Bean&#10;  public ReactiveJwtDecoder jwtDecoder() {&#10;    return token -&gt; {&#10;      if (token == null || token.isBlank()) {&#10;        return Mono.error(new RuntimeException(&quot;JWT token is missing or empty&quot;));&#10;      }&#10;      try {&#10;        var claimsJws = Jwts.parserBuilder()&#10;            .setSigningKey(Keys.hmacShaKeyFor(jwtSecret.getBytes()))&#10;            .build()&#10;            .parseClaimsJws(token);&#10;        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;(claimsJws.getBody());&#10;        Jwt jwt = new Jwt(&#10;            token,&#10;            Instant.ofEpochMilli(claimsJws.getBody().getIssuedAt().getTime()),&#10;            Instant.ofEpochMilli(claimsJws.getBody().getExpiration().getTime()),&#10;            Map.of(&quot;alg&quot;, &quot;HS256&quot;),&#10;            claims&#10;        );&#10;        return Mono.just(jwt);&#10;      } catch (Exception e) {&#10;        return Mono.error(new RuntimeException(&quot;Invalid JWT&quot;, e));&#10;      }&#10;    };&#10;  }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/WebClientConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/configuration/WebClientConfig.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/domain/LoginResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/domain/LoginResponse.java" />
              <option name="updatedContent" value="package com.pichincha.movement.domain;&#10;&#10;import java.util.Map;&#10;&#10;public record LoginResponse(&#10;  String token,&#10;  String refreshToken,&#10;  long expiresIn,&#10;  Map&lt;String, Object&gt; user&#10;) {&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/AuthService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/AuthService.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginRequest.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/dto/LoginResponse.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/impl/AuthServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/movement-service/src/main/java/com/pichincha/movement/service/impl/AuthServiceImpl.java" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>